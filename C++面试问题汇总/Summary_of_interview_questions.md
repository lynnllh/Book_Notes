# C++面试问题汇总
## 什么是虚函数？什么是纯虚函数？

虚函数声明如下： virtual ReturnType FunctionName(Parameter)；引入虚函数是为了动态绑定。 
纯虚函数声明如下：virtual ReturnType FunctionName()= 0；引入纯虚函数是为了派生接口。 

#### 虚函数 

定义一个函数为虚函数，不代表函数为不被实现的函数，定义他为虚函数是为了允许用基类的指针来调用子类的这个函数

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再在派生类中声明该方法为虚方法。

当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = &b;]，父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，会调用父类的函数），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的（发生在编译阶段）。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。 
动态联编的好处是：省事。用父类的指针就可以调用不同的子类中的虚函数。

#### 纯虚函数

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

#### 引入原因：
* 为了方便使用多态特性，我们常常需要在基类中定义虚函数。 
* 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，
但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 
* 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。 
纯虚函数最显著的特征是：它们必须在继承类中重新声明函数，而且它们在抽象类中往往没有定义。
 
------------------
## 纯虚函数是否可以实例化

c++中包含纯虚函数的类是不允许被实例化的！！！，进一步说，如果继承该类的类不重写这个纯虚函数的话，也是不允许被实例化的。

为什么要有这个机制呢？
 
例如动物可以派生出猫、狗等。 猫和狗可以实例化，而动物这个概念是不可以实例化的。

---------------
## 不能声明为虚函数的有哪些
* 静态成员函数
* 类外的普通函数
* 构造函数
* 友元函数
* 内联函数

虚函数是为了实现多态特性的。虚函数的调用只有在程序运行的时候才能知道到底调用的是哪个函数。有以下几点注意事项：

* 类的构造函数不能是虚函数。
从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。
*  类的静态成员函数不能是虚函数。
类的静态成员函数是该类共用的，与该类的对象无关，静态函数里没有this指针，所以不能为虚函数。
* 内联函数。
内联函数的目的是为了减少函数调用时间。它是把内联函数的函数体在编译器预处理的时候替换到函数调用处，这样代码运行到这里时候就不需要花时间去调用函数。而虚函数是动态联编，是在运行是确定该调用什么函数，因此与内联函数的初衷相矛盾。
* 友元函数。
友元函数与该类无关，没有this指针，所以不能为虚函数。

-----------------
## 基类为什么需要虚析构函数
防止内存泄露，delete p（基类）的时候，它很机智的先执行了派生类的析构函数，然后执行了基类的析构函数。 
如果基类的析构函数不是虚函数，在delete p（基类）时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，也就是说只会调用基类的析构函数，这样就会造成内存泄露。

-----------------
## 如何初始化const和static数据成员
const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。 
static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。

在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static

在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。

const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。而且只有 static const 的整型(bool，char，int，long)可以在类声明中初始化，static const的其他类型也必须在类外初始化(包括整型的数组)。

-------------------------
## 如何确保对象在抛出异常时也能被删除？什么是RAII？
#### 有两种方法：
* RAII（资源获取即初始化）：本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来。RAII的做法是设计一个class，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。
* 使用智能指针（是RAII最具代表的实现）

c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被c++11弃用。

为什么要使用智能指针：我们知道c++的内存管理是让很多人头疼的事，当我们写一个new语句时，一般就会立即把delete语句直接也写了，但是我们不能避免程序还未执行到delete时就跳转了或者在函数中没有执行到最后的delete语句就返回了，如果我们不在每一个可能跳转或者返回的语句前释放资源，就会造成内存泄露。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。

---------------------------
## 为什么需要private继承
private继承与public的继承是完全不同的，主要体现在两个地方：

其一，public继承在子类中保持父类的访问权限，即父类中是public的成员函数或成员变量，在子类中仍是public，对private或者protected的成员函数或成员变量亦是如此；但private继承则不是这样了，它破坏了父类中的访问权限标定，将之都转成private，这对子类本身并无影响（照常访问），但却影响了子类的子类，子类的子类将无法访问这些声明/定义在爷爷辈类的成员变量或成员函数。

其二，Liskov法则不再适用，也就是说“一切父类出现的地方都可以被子类所替代”的法则在private这里不成立

公有继承是接口继承，私有继承是实现继承，保护继承是莫名其妙。一般来说对象的封装就是，数据（成员变量）是私有的，接口（成员函数）是公开的。接口继承就是父类的接口，在子类中也是公开的。在任何父类可以使用的地方，都可以替换为子类。实现继承就是，大概就是要在子类中使用了父类的接口（不然你继承它干嘛？），但是又不想外部用跟父类一样的使用方法来使用子类。其实就是一般意义上的代码复用，可以用组合替代继承来优化设计。Private继承在软件“设计”层面上没有意义，其意义只及于软件实现层面。

--------------------
## 如果在构造函数和析构函数中抛出异常会发生什么？什么是栈展开？
抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。首先检查throw本身是否在try块内部，如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。这个过程称为栈展开（stack unwinding）。当处理该异常的catch结束之后，紧接着该catch之后的点继续执行。

#### 为局部对象调用析构函数
如上所述，在栈展开的过程中，会释放局部对象所占用的内存并运行类类型局部对象的析构函数。但需要注意的是，如果一个块通过new动态分配内存，并且在释放该资源之前发生异常，该块因异常而退出，那么在栈展开期间不会释放该资源，编译器不会删除该指针，这样就会造成内存泄露。

#### 析构函数应该从不抛出异常
在为某个异常进行栈展开的时候，析构函数如果又抛出自己的未经处理的另一个异常，将会导致调用标准库terminate函数。通常terminate函数将调用abort函数，导致程序的非正常退出。所以析构函数应该从不抛出异常。

#### 异常与构造函数
如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，要保证能够适当的撤销这些已构造的成员。因为在构造函数中抛出异常，在概念上将被视为该对象没有被成功构造，因此当前对象的析构函数就不会被调用。同时，由于构造函数本身也是一个函数，在函数体内抛出异常将导致当前函数运行结束，并释放已经构造的成员对象，包括其基类的成员，即执行直接基类和成员对象的析构函数。因此如果在构造函数中通过new动态分配了内存，并且因异常而退出，栈展开不会释放该资源，会引起内存泄漏。

#### 未捕获的异常将会终止程序
不能不处理异常。如果找不到匹配的catch，程序就会调用库函数terminate。

---------------------
## 如何在const成员函数中赋值
在类成员函数的后面加上const：void fun() const:{}，就称为const成员函数，该函数可以操作成员，但是不可以修改数据成员的内容，假设在fun中给成员变量赋值，则会出错。const函数能被常量对象以及普通对象调用，但是常量对象只能调用const函数。

想要在const成员函数中赋值，需要利用C++的一个与const相关的摆动厂：mutable（可变的）。加了mutable，说明这些成员变量可能总是会改变，即使是在const成员函数内。mutable加在变量声明处。

--------------------
## 两种常用的实现隐式类类型转换的方式是什么？如何避免隐式类型转换？
```
class Fruit               //定义一个类，名字叫Fruit
{
 string name;     //定义一个name成员           
 string colour;   //定义一个colour成员
 
public:
 bool isSame(const Fruit &otherFruit)   //期待的形参是另一个Fruit类对象，测试是否同名
 {
  return name == otherFruit.name;
 }
 void print()              //定义一个输出名字的成员print()
 {
  cout<<color<<" "<<name<<endl;
 }
 Fruit(const string &nst,const string &cst = "green"):name(nst),colour(cst){}  //构造函数
 
 Fruit(){}
};

int main()
{
 Fruit apple("apple");
 Fruit orange("orange");
 cout<<"apple = orange ?: "<<apple.isSame(orange)<<endl;  //没有问题，肯定不同
 cout<<"apple = /"apple/" ?:"<<apple.isSame(string("apple")); //用一个string做形参？
 
    return 0;
}
```
你会发现最后的使用上，我们用一个string类型作一个期待Fruit类形参的函数的参数，结果竟然得出了是true（1），不要感到奇怪，这就是我现在要讲的东西，隐式类类型转换：“可以用单个实参来调用的构造函数定义了从形参类型到该类型的一个隐式转换。”（C++ Primer)首先要单个实参，你可以把构造函数colour的默认实参去掉，也就是定义一个对象必须要两个参数的时候，文件编译不能通过。然后满足这个条件后，系统就知道怎么转换了，不过这里比较严格：）以前我们构造对象的时候Fruit apple("apple")其实也已经有了一个转换,从const char *的C字符串格式，转为string，在这里，你再apple.isSame("apple")的话，蠢系统不懂得帮你转换两次，所以你必须要用string（）来先强制转换，然后系统才知道帮你从string隐式转换为Fruit，当然其实你自己也可以帮他完成。cout<<"apple = /"apple/" ?:"<<apple.isSame(Fruit("apple"));这样。参考例子1.2 ：Fruit apple = Fruit("apple");  //定义一个Fruit类对象apple。也就是这样转换的。不过这就叫显式转换了，我们不标出来，系统帮我们完成的，叫隐式的贝。这里要说的是，假如你显示转换就可以不管有多少参数了，比如在前面提到的必须需要两个参数的构造函数时的例子。

```
class Fruit               //定义一个类，名字叫Fruit
{
 string name;     //定义一个name成员           
 string colour;   //定义一个colour成员
 
public:
 bool isSame(const Fruit &otherFruit)   //期待的形参是另一个Fruit类对象，测试是否同名
 {
  return name == otherFruit.name;
 }
 void print()              //定义一个输出名字的成员print()
 {
  cout<<colour<<" "<<name<<endl;
 }
 Fruit(const string &nst,const string &cst):name(nst),colour(cst){}  //构造函数
 
 Fruit(){}
};

int main()
{
 Fruit apple("apple","green");
 Fruit orange("orange","yellow");
 cout<<"apple = orange ?: "<<apple.isSame(orange)<<endl;  //没有问题，肯定不同
 cout<<"apple = /"apple/" ?:"<<apple.isSame(Fruit("apple","green")); //显式转换 
    return 0;
}
```
在你不想隐式转换，以防用户误操作怎么办？C++提供了一种抑制构造函数隐式转换的办法，就是在构造函数前面加explicit关键字，你试试就知道，那时你再希望隐式转换就会导致编译失败，但是，要说明的是，显式转换还是可以进行。

第二种方法是使用operator what_you_want_to_convert_type() const
```
 class A
        {
        public:
                operator char*() const
                {
                    return data;//当从其他类型转换到char*时自动调用
                }
        private:
                char* data;
        };
```

再谈一谈C++中的类型转换
C++中共有四种类型转换的方式：static_cast 、dynamic_cast、 reindivter_cast、 const_cast

#### static_cast
用法：static_cast < type-id > ( exdivssion ) 
* 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。
* 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
* 把空指针转换成目标类型的空指针。
* 把任何类型的表达式转换成void类型。

#### dynamic_cast
用法：dynamic_cast < type-id > ( exdivssion )
该运算符把exdivssion转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么exdivssion也必须是一个指针，如果type-id是一个引用，那么exdivssion也必须是一个引用。dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast 的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast 更安全。

#### 上行转换与下行转换
指针类型可以分为两种：指向父类的指针和指向子类的指针，简称为父指针和子指针。以及两种对象:父类对象和子类对象。因此会出现四种情况：父指针指向父对象，父指针指向子对象（虚函数、多态）；子指针指向父对象（危险，因为子指针可以调用子类的方法，但是子指针指向的父对象中没有子类的方法，因此会出错），子指针指向子对象。针对上行转换而言，是将子指针变成父指针，而父指针无论指向父对象还是子对象都是安全的，因此上行转换是安全的的；针对下行转换而言，是将父指针变成子指针，而子指针指向父对象是很危险的，因此下行转换会有一定的危险。


-------------
## 进程、线程、多线程
#### 进程
狭义定义：进程就是一段程序的执行过程。
广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
简单的来讲进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。
进程状态：进程有三个状态，就绪、运行和阻塞。就绪状态其实就是获取了除cpu外的所有资源，只要处理器分配资源就可以马上执行。就绪状态有排队序列什么的，排队原则不再赘述。运行态就是获得了处理器分配的资源，程序开始执行。阻塞态，当程序条件不够时候，需要等待条件满足时候才能执行，如等待i/o操作时候，此刻的状态就叫阻塞态。

#### 程序
说起进程，就不得不说下程序。先看定义：程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是在处理机上的一次执行过程，它是一个动态的概念。这个不难理解，其实进程是包含程序的，进程的执行离不开程序，进程中的文本区域就是代码区，也就是程序。

#### 线程
通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。

#### 多线程
在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。
最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。

#### 进程与线程的区别
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
* 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
* 线程的划分尺度小于进程，使得多线程程序的并发性高。
* 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
* 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
* 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

#### 优缺点
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。

#### 一个比喻
计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。
操作系统的设计，因此可以归结为三点：
* 以多进程形式，允许多个任务同时运行；
* 以多线程形式，允许单个任务分成不同的部分运行；
* 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。

---------------------
## 死锁
#### 定义
线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。

当然死锁的产生是必须要满足一些特定条件的：
* 互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放 
* 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。 
* 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用 
* 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

 线程Thread1率先占有了resource1, 继续运行时需要resource2, 但此时resource2却被线程Thread2占有了，因此只能等待Thread2释放resource2才能够继续运行； 同时，Thread2也需要resource1,它只能等待Thread1释放resource1才能够继续运行， 因此，Thread1和Thread2都处于等待状态， 谁也无法继续运行，即产生了死锁。
 
 #### 避免死锁
 ##### 加锁顺序
 当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。
 例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。
 ##### 加锁时限
 另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。
 
 ##### 死锁检测
 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。
每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。
当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。
当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。

那么当检测出死锁时，这些线程该做些什么呢？
一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。
一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。

---------------
## TCP三次握手和四次挥手
#### 三次握手
所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程：
* 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
* 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
* 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

#### SYN攻击
在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：#netstat -nap | grep SYN_RECV

#### 四次挥手
所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程：
 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
 * 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
 * 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
 * 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
 * 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
 
 #### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。
 
 ------------
------------------------
------------------------
 ## C/C++中的多态
 #### 定义
 多态的定义简单来说就是使一条语句有多种状态。
 #### 实现方式
 多态的实现方式分为三块：重载、重写、重定义。下面我们来谈一谈他们各自的实现方式和实现原理。
 #### 重载
 ##### 实现方式
 重载是在同一作用域内（不管是模块内还是类内，只要是在同一作用域内），具有相同函数名，不同的形参个数或者形参类型。返回值可以相同也可以不同（在函数名、形参个数、形参类型都相同而返回值类型不同的情况下无法构成重载，编译器报错。这个道理很简单，在函数调用的时候是不看返回值类型的）。
 ##### 实现原理
 重载是一种静态多态，即在编译的时候确定的。C++实现重载的方式是跟编译器有关，编译过后C++的函数名会发生改变，会带有形参个数、类型以及返回值类型的信息（虽然带有返回值类型但是返回值类型不能区分这个函数），所以编译器能够区分具有不同形参个数或者类型以及相同函数名的函数。插一句，在C语言中编译器编译过后函数名中不会带有形参个数以及类型的信息，因此C语言没有重载的特性。由此带来麻烦的一点是如果想要在C++中调用C语言的库，需要特殊的操作（extern "C"{}）。库中的函数经过C编译器编译的话会生成不带有形参信息的函数名，而用C++的编译器编译过后会生成带有形参信息的函数名，因此将会找不到这个函数。extern "C"{}的作用是使在这个作用域中的语句用C编译器编译，这样就不会出错。这也是一种语言兼容性的问题。
 #### 重写
 ##### 实现方式
 重写是在不同作用域内（一个在父类一个在子类），函数名、形参个数、形参类型、返回值类型都相同并且父类中带有virtual关键字（换言之子类中带不带virtual都没有关系）。有一种特殊的情况：函数返回值类型可以不同但是必须是指针或者引用，并且两个虚函数的返回值之间必须要构成父子类关系。这种情况称之为协变，也是一种重写。引入协变的好处是为了避免危险的类型转换。
 ##### 实现原理
 重写是一种动态多态，即在运行时确定的。C++实现重写的方式也跟编译器有关，编译器在实例化一个具有虚函数的类时会生成一个vptr指针（这就是为什么静态函数、友元函数不能声明为虚函数，因为它们不实例化也可以调用，而虚函数必须要实例化，这也是为什么构造函数不能声明为虚函数，因为你要调用虚函数必须得要有vptr指针，而构造函数此时还没有被调用，内存中还不存在vptr指针，逻辑上矛盾了）。vptr指针在类的内存空间中占最低地址的四字节。vptr指针指向的空间称为虚函数表，vptr指针指向其表头，在虚函数表里面按声明顺序存放了虚函数的函数指针，如果在子类中重写了，在子类的内存空间中也会产生一个vptr指针，同时会把父类的虚函数表copy一下当做自己的，然后如果在子类中重新声明了虚函数，会按声明顺序接在父类的虚函数函数指针下。而子类中重写的虚函数则会替换掉虚函数表中原先父类的虚函数函数指针。重点来了，在调用虚函数时，不管调用他的是父类的指针、引用还是子类的指针、引用，他都不管，只看他所指向或者引用的对象的类型（这也称为动态联编），如果是父类的对象，那就调用父类里面的vptr指针然后找到相应的虚函数，如果是子类的对象，那就调用子类里面的vptr指针然后找到相应的虚函数。当然这样子的过程相比静态多态而言，时间和空间上的开销都多了（这也是为什么内联函数为什么不能声明为虚函数，因为这和内联函数加快执行速度的初衷相矛盾）。
 #### 重定义
 ##### 实现方式
 重定义是在不同作用域内的（一个在父类一个在子类），只要函数名相同，且不构成重写，均称之为重定义
 ##### 实现原理
 重定义的实现原理跟继承树中函数的寻找方式有关，他会从当前对象的类作用域内开始查找同名的函数，如果没有找到就一直向上查找直到基类为止。如果找到一个同名的函数就停止。这也就说明他不管函数的形参类型或者个数是不是一样，只要函数名一样，他就认为是找到了，如果这时候形参类型或者个数不一致，编译器就会报错。多重继承的查找，如果在同一层内出现一样的函数声明那么编译器会报错不知道调用哪一个函数，这类问题也叫钻石继承问题。钻石问题的解决方案可以通过虚继承来实现，这样就不会存在多个一样的函数声明。