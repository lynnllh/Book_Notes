# C++面试问题汇总
## 什么是虚函数？什么是纯虚函数？

虚函数声明如下： virtual ReturnType FunctionName(Parameter)；引入虚函数是为了动态绑定。 
纯虚函数声明如下：virtual ReturnType FunctionName()= 0；引入纯虚函数是为了派生接口。 

#### 虚函数 

定义一个函数为虚函数，不代表函数为不被实现的函数，定义他为虚函数是为了允许用基类的指针来调用子类的这个函数

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再在派生类中声明该方法为虚方法。

当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = &b;]，父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，会调用父类的函数），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的（发生在编译阶段）。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。 
动态联编的好处是：省事。用父类的指针就可以调用不同的子类中的虚函数。

#### 纯虚函数

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

#### 引入原因：
* 为了方便使用多态特性，我们常常需要在基类中定义虚函数。 
* 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，
但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 
* 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。 
纯虚函数最显著的特征是：它们必须在继承类中重新声明函数，而且它们在抽象类中往往没有定义。
 
------------------
## 纯虚函数是否可以实例化

c++中包含纯虚函数的类是不允许被实例化的！！！，进一步说，如果继承该类的类不重写这个纯虚函数的话，也是不允许被实例化的。

为什么要有这个机制呢？
 
例如动物可以派生出猫、狗等。 猫和狗可以实例化，而动物这个概念是不可以实例化的。

---------------
## 不能声明为虚函数的有哪些
* 静态成员函数
* 类外的普通函数
* 构造函数
* 友元函数
* 内联函数

虚函数是为了实现多态特性的。虚函数的调用只有在程序运行的时候才能知道到底调用的是哪个函数。有以下几点注意事项：

* 类的构造函数不能是虚函数。
从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。
*  类的静态成员函数不能是虚函数。
类的静态成员函数是该类共用的，与该类的对象无关，静态函数里没有this指针，所以不能为虚函数。
* 内联函数。
内联函数的目的是为了减少函数调用时间。它是把内联函数的函数体在编译器预处理的时候替换到函数调用处，这样代码运行到这里时候就不需要花时间去调用函数。而虚函数是动态联编，是在运行是确定该调用什么函数，因此与内联函数的初衷相矛盾。
* 友元函数。
友元函数与该类无关，没有this指针，所以不能为虚函数。

-----------------
## 基类为什么需要虚析构函数
防止内存泄露，delete p（基类）的时候，它很机智的先执行了派生类的析构函数，然后执行了基类的析构函数。 
如果基类的析构函数不是虚函数，在delete p（基类）时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，也就是说只会调用基类的析构函数，这样就会造成内存泄露。

-----------------
## 如何初始化const和static数据成员
const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。 
static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。

在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static

在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。

const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。而且只有 static const 的整型(bool，char，int，long)可以在类声明中初始化，static const的其他类型也必须在类外初始化(包括整型的数组)。

-------------------------
## 如何确保对象在抛出异常时也能被删除？什么是RAII？
#### 有两种方法：
* RAII（资源获取即初始化）：本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来。RAII的做法是设计一个class，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。
* 使用智能指针（是RAII最具代表的实现）

c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被c++11弃用。

为什么要使用智能指针：我们知道c++的内存管理是让很多人头疼的事，当我们写一个new语句时，一般就会立即把delete语句直接也写了，但是我们不能避免程序还未执行到delete时就跳转了或者在函数中没有执行到最后的delete语句就返回了，如果我们不在每一个可能跳转或者返回的语句前释放资源，就会造成内存泄露。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。

---------------------------
## 为什么需要private继承
private继承与public的继承是完全不同的，主要体现在两个地方：

其一，public继承在子类中保持父类的访问权限，即父类中是public的成员函数或成员变量，在子类中仍是public，对private或者protected的成员函数或成员变量亦是如此；但private继承则不是这样了，它破坏了父类中的访问权限标定，将之都转成private，这对子类本身并无影响（照常访问），但却影响了子类的子类，子类的子类将无法访问这些声明/定义在爷爷辈类的成员变量或成员函数。

其二，Liskov法则不再适用，也就是说“一切父类出现的地方都可以被子类所替代”的法则在private这里不成立

公有继承是接口继承，私有继承是实现继承，保护继承是莫名其妙。一般来说对象的封装就是，数据（成员变量）是私有的，接口（成员函数）是公开的。接口继承就是父类的接口，在子类中也是公开的。在任何父类可以使用的地方，都可以替换为子类。实现继承就是，大概就是要在子类中使用了父类的接口（不然你继承它干嘛？），但是又不想外部用跟父类一样的使用方法来使用子类。其实就是一般意义上的代码复用，可以用组合替代继承来优化设计。Private继承在软件“设计”层面上没有意义，其意义只及于软件实现层面。

--------------------
## 如果在构造函数和析构函数中抛出异常会发生什么？什么是栈展开？
抛出异常时，将暂停当前函数的执行，开始查找匹配的catch子句。首先检查throw本身是否在try块内部，如果是，检查与该try相关的catch子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的catch。这个过程称为栈展开（stack unwinding）。当处理该异常的catch结束之后，紧接着该catch之后的点继续执行。

#### 为局部对象调用析构函数
如上所述，在栈展开的过程中，会释放局部对象所占用的内存并运行类类型局部对象的析构函数。但需要注意的是，如果一个块通过new动态分配内存，并且在释放该资源之前发生异常，该块因异常而退出，那么在栈展开期间不会释放该资源，编译器不会删除该指针，这样就会造成内存泄露。

#### 析构函数应该从不抛出异常
在为某个异常进行栈展开的时候，析构函数如果又抛出自己的未经处理的另一个异常，将会导致调用标准库terminate函数。通常terminate函数将调用abort函数，导致程序的非正常退出。所以析构函数应该从不抛出异常。

#### 异常与构造函数
如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，要保证能够适当的撤销这些已构造的成员。因为在构造函数中抛出异常，在概念上将被视为该对象没有被成功构造，因此当前对象的析构函数就不会被调用。同时，由于构造函数本身也是一个函数，在函数体内抛出异常将导致当前函数运行结束，并释放已经构造的成员对象，包括其基类的成员，即执行直接基类和成员对象的析构函数。因此如果在构造函数中通过new动态分配了内存，并且因异常而退出，栈展开不会释放该资源，会引起内存泄漏。

#### 未捕获的异常将会终止程序
不能不处理异常。如果找不到匹配的catch，程序就会调用库函数terminate。

---------------------
## 如何在const成员函数中赋值
在类成员函数的后面加上const：void fun() const:{}，就称为const成员函数，该函数可以操作成员，但是不可以修改数据成员的内容，假设在fun中给成员变量赋值，则会出错。const函数能被常量对象以及普通对象调用，但是常量对象只能调用const函数。

想要在const成员函数中赋值，需要利用C++的一个与const相关的摆动厂：mutable（可变的）。加了mutable，说明这些成员变量可能总是会改变，即使是在const成员函数内。mutable加在变量声明处。

--------------------
## 两种常用的实现隐式类类型转换的方式是什么？如何避免隐式类型转换？
```
class Fruit               //定义一个类，名字叫Fruit
{
 string name;     //定义一个name成员           
 string colour;   //定义一个colour成员
 
public:
 bool isSame(const Fruit &otherFruit)   //期待的形参是另一个Fruit类对象，测试是否同名
 {
  return name == otherFruit.name;
 }
 void print()              //定义一个输出名字的成员print()
 {
  cout<<color<<" "<<name<<endl;
 }
 Fruit(const string &nst,const string &cst = "green"):name(nst),colour(cst){}  //构造函数
 
 Fruit(){}
};

int main()
{
 Fruit apple("apple");
 Fruit orange("orange");
 cout<<"apple = orange ?: "<<apple.isSame(orange)<<endl;  //没有问题，肯定不同
 cout<<"apple = /"apple/" ?:"<<apple.isSame(string("apple")); //用一个string做形参？
 
    return 0;
}
```
你会发现最后的使用上，我们用一个string类型作一个期待Fruit类形参的函数的参数，结果竟然得出了是true（1），不要感到奇怪，这就是我现在要讲的东西，隐式类类型转换：“可以用单个实参来调用的构造函数定义了从形参类型到该类型的一个隐式转换。”（C++ Primer)首先要单个实参，你可以把构造函数colour的默认实参去掉，也就是定义一个对象必须要两个参数的时候，文件编译不能通过。然后满足这个条件后，系统就知道怎么转换了，不过这里比较严格：）以前我们构造对象的时候Fruit apple("apple")其实也已经有了一个转换,从const char *的C字符串格式，转为string，在这里，你再apple.isSame("apple")的话，蠢系统不懂得帮你转换两次，所以你必须要用string（）来先强制转换，然后系统才知道帮你从string隐式转换为Fruit，当然其实你自己也可以帮他完成。cout<<"apple = /"apple/" ?:"<<apple.isSame(Fruit("apple"));这样。参考例子1.2 ：Fruit apple = Fruit("apple");  //定义一个Fruit类对象apple。也就是这样转换的。不过这就叫显式转换了，我们不标出来，系统帮我们完成的，叫隐式的贝。这里要说的是，假如你显示转换就可以不管有多少参数了，比如在前面提到的必须需要两个参数的构造函数时的例子。

```
class Fruit               //定义一个类，名字叫Fruit
{
 string name;     //定义一个name成员           
 string colour;   //定义一个colour成员
 
public:
 bool isSame(const Fruit &otherFruit)   //期待的形参是另一个Fruit类对象，测试是否同名
 {
  return name == otherFruit.name;
 }
 void print()              //定义一个输出名字的成员print()
 {
  cout<<colour<<" "<<name<<endl;
 }
 Fruit(const string &nst,const string &cst):name(nst),colour(cst){}  //构造函数
 
 Fruit(){}
};

int main()
{
 Fruit apple("apple","green");
 Fruit orange("orange","yellow");
 cout<<"apple = orange ?: "<<apple.isSame(orange)<<endl;  //没有问题，肯定不同
 cout<<"apple = /"apple/" ?:"<<apple.isSame(Fruit("apple","green")); //显式转换 
    return 0;
}
```
在你不想隐式转换，以防用户误操作怎么办？C++提供了一种抑制构造函数隐式转换的办法，就是在构造函数前面加explicit关键字，你试试就知道，那时你再希望隐式转换就会导致编译失败，但是，要说明的是，显式转换还是可以进行。

第二种方法是使用operator what_you_want_to_convert_type() const
```
 class A
        {
        public:
                operator char*() const
                {
                    return data;//当从其他类型转换到char*时自动调用
                }
        private:
                char* data;
        };
```

再谈一谈C++中的类型转换
C++中共有四种类型转换的方式：static_cast 、dynamic_cast、 reindivter_cast、 const_cast

#### static_cast
用法：static_cast < type-id > ( exdivssion ) 
* 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。
* 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
* 把空指针转换成目标类型的空指针。
* 把任何类型的表达式转换成void类型。

#### dynamic_cast
用法：dynamic_cast < type-id > ( exdivssion )
该运算符把exdivssion转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么exdivssion也必须是一个指针，如果type-id是一个引用，那么exdivssion也必须是一个引用。dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast 的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast 更安全。

#### 上行转换与下行转换
指针类型可以分为两种：指向父类的指针和指向子类的指针，简称为父指针和子指针。以及两种对象:父类对象和子类对象。因此会出现四种情况：父指针指向父对象，父指针指向子对象（虚函数、多态）；子指针指向父对象（危险，因为子指针可以调用子类的方法，但是子指针指向的父对象中没有子类的方法，因此会出错），子指针指向子对象。针对上行转换而言，是将子指针变成父指针，而父指针无论指向父对象还是子对象都是安全的，因此上行转换是安全的的；针对下行转换而言，是将父指针变成子指针，而子指针指向父对象是很危险的，因此下行转换会有一定的危险。

