# C++面试问题汇总
## 什么是虚函数？什么是纯虚函数？

虚函数声明如下： virtual ReturnType FunctionName(Parameter)；引入虚函数是为了动态绑定。 
纯虚函数声明如下：virtual ReturnType FunctionName()= 0；引入纯虚函数是为了派生接口。 

#### 虚函数 

定义一个函数为虚函数，不代表函数为不被实现的函数，定义他为虚函数是为了允许用基类的指针来调用子类的这个函数

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再在派生类中声明该方法为虚方法。

当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = &b;]，父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，会调用父类的函数），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的（发生在编译阶段）。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。 
动态联编的好处是：省事。用父类的指针就可以调用不同的子类中的虚函数。

#### 纯虚函数

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”

#### 引入原因：
* 为了方便使用多态特性，我们常常需要在基类中定义虚函数。 
* 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，
但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 
* 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。 
纯虚函数最显著的特征是：它们必须在继承类中重新声明函数，而且它们在抽象类中往往没有定义。
 
------------------
## 纯虚函数是否可以实例化

c++中包含纯虚函数的类是不允许被实例化的！！！，进一步说，如果继承该类的类不重写这个纯虚函数的话，也是不允许被实例化的。

为什么要有这个机制呢？
 
例如动物可以派生出猫、狗等。 猫和狗可以实例化，而动物这个概念是不可以实例化的。

---------------
## 不能声明为虚函数的有哪些
* 静态成员函数
* 类外的普通函数
* 构造函数
* 友元函数
* 内联函数

虚函数是为了实现多态特性的。虚函数的调用只有在程序运行的时候才能知道到底调用的是哪个函数。有以下几点注意事项：

* 类的构造函数不能是虚函数。
从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。
*  类的静态成员函数不能是虚函数。
类的静态成员函数是该类共用的，与该类的对象无关，静态函数里没有this指针，所以不能为虚函数。
* 内联函数。
内联函数的目的是为了减少函数调用时间。它是把内联函数的函数体在编译器预处理的时候替换到函数调用处，这样代码运行到这里时候就不需要花时间去调用函数。而虚函数是动态联编，是在运行是确定该调用什么函数，因此与内联函数的初衷相矛盾。
* 友元函数。
友元函数与该类无关，没有this指针，所以不能为虚函数。

-----------------
## 基类为什么需要虚析构函数
防止内存泄露，delete p（基类）的时候，它很机智的先执行了派生类的析构函数，然后执行了基类的析构函数。 
如果基类的析构函数不是虚函数，在delete p（基类）时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，也就是说只会调用基类的析构函数，这样就会造成内存泄露。

-----------------
## 如何初始化const和static数据成员
const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。 
static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。

在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static

在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。

const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。而且只有 static const 的整型(bool，char，int，long)可以在类声明中初始化，static const的其他类型也必须在类外初始化(包括整型的数组)。

-------------------------
## 如何确保对象在抛出异常时也能被删除？什么是RAII？
#### 有两种方法：
* RAII（局部对象管理资源的技术）：本质内容是用对象代表资源，把管理资源的任务转化为管理对象的任务，将资源的获取和释放与对象的构造和析构对应起来。RAII的做法是设计一个class，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。
* 使用智能指针

c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被c++11弃用。

为什么要使用智能指针：我们知道c++的内存管理是让很多人头疼的事，当我们写一个new语句时，一般就会立即把delete语句直接也写了，但是我们不能避免程序还未执行到delete时就跳转了或者在函数中没有执行到最后的delete语句就返回了，如果我们不在每一个可能跳转或者返回的语句前释放资源，就会造成内存泄露。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。

---------------------------
## 为什么需要private继承
private继承与public的继承是完全不同的，主要体现在两个地方：

其一，public继承在子类中保持父类的访问权限，即父类中是public的成员函数或成员变量，在子类中仍是public，对private或者protected的成员函数或成员变量亦是如此；但private继承则不是这样了，它破坏了父类中的访问权限标定，将之都转成private，这对子类本身并无影响（照常访问），但却影响了子类的子类，子类的子类将无法访问这些声明/定义在爷爷辈类的成员变量或成员函数。

其二，Liskov法则不再适用，也就是说“一切父类出现的地方都可以被子类所替代”的法则在private这里不成立

公有继承是接口继承，私有继承是实现继承，保护继承是莫名其妙。一般来说对象的封装就是，数据（成员变量）是私有的，接口（成员函数）是公开的。接口继承就是父类的接口，在子类中也是公开的。在任何父类可以使用的地方，都可以替换为子类。实现继承就是，大概就是要在子类中使用了父类的接口（不然你继承它干嘛？），但是又不想外部用跟父类一样的使用方法来使用子类。其实就是一般意义上的代码复用，可以用组合替代继承来优化设计。Private继承在软件“设计”层面上没有意义，其意义只及于软件实现层面。

--------------------
## 如果在构造函数和析构函数中抛出异常会发生什么？什么是栈展开？
